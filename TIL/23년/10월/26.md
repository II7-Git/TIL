# 23.10.26 TIL

## 알고리즘

### [백준*5002*도어맨 ](https://www.acmicpc.net/problem/5002)

들어가는 남자의 수와 여자의 수를 파악해가면서 그 인원 수의 차이를 잘 체크해주어야하는 문제였다. 체크해서 만약 바꿀 수 있다면 swap()함수를 써서 간단히 해결이 가능했다.

문자열과 논리를 같이 사용해서 풀어야 했던 문제였다.

### [백준*17352*여러분의 다리가 되어 드리겠습니다!](https://www.acmicpc.net/problem/17352)

모두가 연결된 그래프의 형태에서 하나의 다리가 끊길때 어떻게든 모든 섬을 연결시키기만 하면 되는 문제였다.
그래서 연결됐는지 여부를 따지는 알고리즘 Union-Find를 써서 섬들을 연결시키고 서로 Parent가 다른 섬이 나올 때 그 섬을 연결시키는 방식으로 문제를 풀었다.

### [백준*1327*소트게임](https://www.acmicpc.net/problem/1327)

순열이 최대 8개기에 이를 문자열 형태로 바꾸어서 카드 뒤집기를 swap()으로 처리하고 경우의 수를 BFS로 턴마다 체크하며 map으로 이미 나온 문자열은 추가해주지 않는 방식으로 가지 치기를 해서 구현했다. 이를 통해서 원하는 문자열이 나오면 그 때의 턴 수를 출력하면 정답이 완성됐다.

### [백준*1744*수 묶기](https://www.acmicpc.net/problem/1744)

수가 커지는 경우의 수를 따져보면 +끼리 처리하고 -끼리 처리해서 무조건 큰 수끼리 묶어야지 더 커졌다.

이 방식을 깨달았다면 그 뒤는 수열을 정렬하고 -끼리 곱했을때 0보다 크거나 같다면 곱해주고<br> +끼리 곱했을 때도 더했을 때보다 크면 곱해주는 방식을 한다.

단 이때 ,1,1곱과 -1,0 곱의 경우의 수를 놓쳐서 코딩하면 실수가 나게 된다.

## 마무리

이번 주는 그리디 알고리즘이 많아서 문제를 어떻게 풀어야할지 해석하는 문제들이 많았다. 알고리즘을 구현하는 것은 쉬웠던 문제들이었지만 대신 그만큼 어떻게 구현할지 생각해내는 것은 어려웠다. 이러한 문제를 많이 풀면 실제 다양한 문제에 직면했을 때 보다 좋은 대처법이 생각나기에 늘 좀 더 새로운 방식으로 풀려고 생각해본다.

이번 주에도 다양한 문제 풀이 방식을 생각해보려 고민했었다.
