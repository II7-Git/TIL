# 23/08/24 TIL

이번 주에 풀었던 알고리즘은 새로운 유형의 응용이 많아서 생각보다 시간이 좀 더 걸리면서 풀었던 것 같다. 전체적으로 한번씩 다시 복기해보겠다.

## 알고리즘

### [백준*1411*비슷한 단어](https://www.acmicpc.net/problem/1411)

단어가 같은 구조끼리 묶어서 쌍이 총 몇개인지 구하는 문제였다. 단어를 패턴화 시켜서 맵으로 묶어 몇개인지 세는 것이 중요한 아이디어였다.

이를 구하면 쌍의 개수는 같은 패턴끼리 묶어서 평소 구하듯이 구하면 됐다

### [백준*1068*트리](https://www.acmicpc.net/problem/1068)

트리는 그래프에서 리프 노드의 개수를 구하는 문제였는데 주의할 점은 지우는 노드가 존재해서 해당 노드를 지웠을 시 그 부모 노드가 리프 노드가 되는지 여부를 체크해줘야한다.

그래서 자식 노드가 있을 때 그 자식 노드가 삭제 노드면 dfs를 하지 않고 총 dfs를 한 횟수를 진짜 자식 노드의 수라고 보게끔 알고리즘을 구성하여 풀었다.

### [백준*20168*골목 대장 호석-기능성](https://www.acmicpc.net/problem/20168)

처음엔 단순히 최소비용 다익스트라로 구현하려 했는데 그럴려고 하니 한 골목의 최대 금액과 총 전체 비용이 달라서 문제가 생겼다.

그래서 일단 갈 수 있으면 다 가보는 dfs를 하며 전체 비용이 넘지 않는 선에서 목적지에 도착했을 시 가장 적은 최대 금액을 갱신 시켜주는 방식으로 문제를 풀었다.

### [백준*16562*친구비](https://www.acmicpc.net/problem/16562)

일단은 그래프를 만들고 친구를 찾아가는 식으로 하려했는데 메모리가 초과났다...

그래서 다시 생각해보니 친구 무리에서 최소 비용의 친구만 알 수 있다면 해당 무리는 전부 해결된다는 점을 알아내어 Union-Find 방식을 써서 최소 비용의 친구를 루트로 하게끔 하여 Union-Find를 구현했고 그 뒤는 각 무리마다 최소 비용에 친구를 비용에 더해주는 방식으로 문제를 풀었다.

## 마무리

이번 주 문제는 알고리즘 자체가 난이도 있지는 않으나 그 응용 방식으로 인해 조금씩 구조가 뒤틀리는 문제가 많았던 것 같다. 그래서 조금 돌아가고 고생한 문제들이 있었는데 이러한 문제가 실제 구현 문제로 많이 나올 수 있겠다는 생각이 들어서 좀 더 자주 풀어보면 좋겠다는 생각이 들었다.
