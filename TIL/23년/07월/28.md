# 23/07/28 TIL

## 알고리즘

알고리즘 4문제를 풀었다

### [백준*2477*참외밭](https://www.acmicpc.net/problem/2477)

참외밭 문제는 결론만 말하면 큰 사각형과 작은 사각형을 크기를 구한 뒤 k를 곱해주면 끝인 문제지만 문제는 작은 사각형을 구하는 방법이었다. 랜덤한 꼭지점에서 반시계방향으로 도는 변을 차례대로 알려주기에 작은 사각형을 구하는 아이디어가 필요했다.

내가 생각한 방법은 결국 같은 모양이 90도씩 회전한 형태들이 주어지기에 반시계 방향으로 돌게 되면 같은 방향의 변이 2번씩 반복되서 나오게되는 구조가 된다는 점에서 착안했다. 예제를 보면 4-2-3-1-3-1 순으로 변의 방향이 주어지는데 이중 3-1-3-1처럼 연속되서 두 변이 반복되어 나오는 구조가 꺾인 사각형의 위치일 수 밖에 없는 구조이고 그 반복중 안에 두 요소 3-(1-3)-1 에서 괄호 안에 있는 두 요소가 작은 사각형의 크기가 된다는 점을 이해했고 이 방식대로 따라 구현만 하면 답은 쉽게 구해졌다.

### [백준*22252*정보 상인 호석](https://www.acmicpc.net/problem/22252)

이 문제는 map과 priority_queue만 잘 활요하면 쉽게 풀 수 있는 문제였다. map을 통해 고릴라 정보상의 priority_queue를 관리하면 쉽게 풀린다.

주의할 점으로는 priority_queue에 크기가 넘어가는 정보를 구매하려는 경우를 잘 체크할 것과 최종 답의 크기가 int의 범위를 넘어가는 경우가 있다는 점 정도였다.

### [백준*16197*두 동전](https://www.acmicpc.net/problem/16197)

두 동전은 bfs를 푸는 방식으로 구현해서 풀면 되지만 보통의 중복 체크 배열보다 좀 더 고난이도의 체크를 요구한다는 점이었다.

이 문제같은 경우는 두 개의 동전이 모두 같은 위치에 있던 경우를 중복체크해야했기에 그 방법으로 4중 배열을 선언해서 중복체크를 진행했다.

그 뒤는 많이 풀었던 구현처럼 조건을 따라가서 구현해주면 되었다.

### [백준*17244*아 맞다 우산](https://www.acmicpc.net/problem/17244)

모든 물건을 챙겨서 나가는 최소 시간을 구하는 문제였다.

문제는 어떠한 물건들을 챙겼는지 체크하면서 BFS를 구현할 지 였고 그 방법으로 채택된 건 비트마스킹이었다.

물건의 각각 번호를 붙이고 비트 연산으로 해당 물건을 챙겼으면 그만큼 '1<<n' 연산으로 해당 물건을 챙긴 것으로 체크하며 중복 배열을 체크해나갔다.

다행히 최대 물건 수가 5개기에 2^5=64개 언저리에 배열만 나오기에 해당 경우를 포함한 3중 체크배열을 선언해도 문제없었다.

그 뒤는 물건을 챙기게 되는 | 연산을 잘 실행하며 구현해준다면 구현이 조금 까다롭지만 그래도 완성할 수 있다. 주의점으로는 최종 E포인트에 도달했을 때 모든 물건을 챙겼는지를 제대로 계산해주어야 한다는 점이었다.

## 소감

이번 주 알고리즘들은 전체적으로 구현이 까다로운 알고리즘 문제들이 많았는데 그래서 좀 더 놓치는 경우 없이 차례대로 따라가면서 구현하려고 노력했다.

이번 주에 썼던 비트마스킹의 방법을 사용한 중복체크 배열은 앞으로 다른 문제들에 대해서도 유용하게 적용시킬 수 있는 방법인 것 같아서 특히 더 그 방식을 기억하려 오래 다시 봤던 것 같다.
