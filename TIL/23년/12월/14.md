# 23.12.14 TIL

## 알고리즘

### [백준-17829-222-풀링](https://www.acmicpc.net/problem/17829)

이차원 배열을 계속해서 나눠주고 모아주는 배열 다루기 문제로 문제의 과정을 이해하면 구현은 차근차근 진행해나가니 크게 어려움은 없던 문제였다.

### [백준-9011-순서](https://www.acmicpc.net/problem/9011)

이 문제는 아이디어를 내기 어려웠는데 예제를 보고 잘 생각해보니 뒤에서부터 계산할 때 아직 정해지지 않은 값의 수가 현재 위치의 R 값보다+1개 이상이어야 가능하다는 것을 알 수 있었다. 그걸 이해하니 약간의 구현으로 문제를 풀 수 있었다.

### [백준-10472-십자 뒤집기](https://www.acmicpc.net/problem/10472)

처음에는 모든칸을 뒤집어 가면서 bfs를 해야하나 생각했는데 잘 보니 9칸 각각 뒤집기를 시도했는지 안했는지만 따져서 경우의 수를 계산하면 됐다. 그래서 각 칸을 뒤집은 경우와 안뒤집은 경우로 나눠 dfs를 하여 최종적인 모습을 계산하는 방법으로 풀게 됐다.

### [백준-30646-최대 합 순서쌍의 개수](https://www.acmicpc.net/problem/30646)

이번 주 문제 중 가장 어려웠던 문제였다. 그냥 같은 값을 순회로 찾으면 시간 초과가 났기에 모든 값이 양수인 점을 파악하여 같은 값의 순서쌍의 좌우 끝을 기록해놓으면 무조건 최대값이 된다는 점을 파악해 같은 값의 좌우 끝 인덱스를 map 형태로 기록하고 배열의 누적합을 기록한 뒤 map을 순회하여 누적합의 차이를 통해 max값을 갱신해주면서 만약 같은 누적합이라면 개수를 더해주는 방식으로 풀었다. 꽤나 복잡한 문제라서 푸는데 신중을 기했다.

## 마무리

이번 주 문제는 기존 알고리즘 문제들과는 결이 조금 달라서 어려웠지만 다양한 풀이를 시도해볼 수 있어서 좋았던 것 같다.
