# 24.04.11 TIL

##

### [백준-1083-소트](https://www.acmicpc.net/problem/1083)

교환을 어떻게 해야 사전순으로 될 수 있을지를 경우의 수를 세워보는 것이 꽤나 복잡했다. 결국 남은 S번 내에서 교환을 한다는 것은 S개 내의 수들 중에서 가장 큰 값이 앞으로 이동한다는 구조를 이해했고 이를 바탕으로 교환을 구현했다.

매번 한칸씩 교환하는 것은 연산에서 손해가 있기에 바꿔야되는 위치의 원소를 삭제하고 넣어야하는 위치에 삽입하고 건너뛴 거리만큼 S를 줄이는 방식으로 구현해서 연산을 줄일 수 있었다.

### [백준-23747-와드](https://www.acmicpc.net/problem/23747)

경로를 지나면서 봤던 모든 곳에 시야가 밝혀지는 줄로 잘못 이해하고 풀었는데 알고보니 최종 위치에서 밝혀진 시야부분들을 표시하는 문제였다. 그래서 각 영역별로 번호를 매기고 와드가 꽂히면 해당 번호의 영역은 전부 시야에 들어왔다 표현하고 플레이어의 마지막 위치에서 상하좌우도 표시해주어서 문제를 제대로 풀어냈다.

### [백준-25556-포스택](https://www.acmicpc.net/problem/25556)

4개의 스택에 쌓을 때 현재 값을 넘지 않는 범위에 스택 윗 값이 존재해야지만 꺼낼 때 오름차순으로 정렬할 수 있는 구조가 된다는 것을 이해하면 문제의 풀이 방향이 보였다.

그래서 먼저 아예 빈 스택은 따로 표시해두고 이미 값이 있는 스택에서 현재 값을 넘지않는 가장 큰 값에 위에 현재 값을 누적하면서 계속 쌓아나가고 혹시 불가하면서 빈 스택조차도 없다면 이 땐 스택에 역순으로 쌓이는 구조가 되서 오름차순 순열로 복구하는 것이 불가하기에 틀렸다고 출력해주었다.

### [백준-8972-미친 아두이노](https://www.acmicpc.net/problem/8972)

구현에 길이가 길었던 문제였는데 아무래도 로봇들의 충돌을 구현하는 부분이 까다로웠다. 각 로봇들의 이동할 좌표를 구하고 해당 좌표로 전부 이동시켜보면서 겹친다면 해당 위치를 CrushPoint로 지정하고 해당 위치에 가게된 로봇들을 전부 사망 처리해주어서 후에 시뮬레이션에서 동작하지 않도록 했다.

로봇들의 사망 처리와 플레이어와 충돌 처리 등 관리해야할 요소들이 많아서 까다로웠지만 그만큼 구현해 보고 나니 좋은 경험이 됐던 문제였다.
