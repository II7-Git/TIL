# 24.07.19 TIL

## CS 공부

### CPU 구조 분석

#### 스택 구조

CPU에서 스택 구조를 활용하는 레지스터 스택과 메모리 스택에 대해서 공부했다.

레지스터 스택의 특징

- 빠르다는 점이 가장 큰 장점
- 주소에 대한 정보만을 가지고 있다

메모리 스택의 특징

- 길이의 제한이 없다
- 메모리의 일부분을 스택 구조로 활용한 형태
- 메모리의 구조 중 프로그램,데이터,스택에서 스택 세그먼트 부분이 바로 이 메모리 스택을 뜻함

두 스택의 차이를 이해하고 각 스택의 장점을 이해하는 것이 중요하다는 생각이 들었다.<br>

#### 명령어 형식: RISC 명령

RISC 프로세서의 명령어 집합은 메모리와 CPU 사이의 통신을 할 때 load와 store명령어만 사용하도록 제한된다. 또 다른 모든 명령어들은 메모리 참조 없이 CPU 레지스터 안에서만 실행되는 것이 특징이다.

RISC 명령어의 특징

```md
- 필요한 데이터를 전부 레지스터에 가져다 놓고 레지스터 내부에서 계산하는 방식으로 처리가 빠르다.
- 계산이 빠르기에 연산량이 많을수록 시간 세이브가 많아짐
- 주소와 레지스터를 오가는 방식에 비해 10배 정도는 시간을 단축시킬 수 있다.
```

이러한 특징을 가지고 있기에 기존보다 효율적인 방식을 가지고 있다.

#### 어드레싱 모드

명령어에는 해당 연산을 진행해야하는 피연산자가 존재하는데 이 피연산자의 메모리 주소를 찾아가는 방식을 어드레싱 모드라고 한다. 이 모드의 기법은 여러가지가 있어 각각의 특징을 이해하면 좋다.

<code>Implied 모드</code><br/>
명령어의 정의에 따라 피연산자가 묵시적으로 정해져 있는 모드이다. 대표적인 예로는 누산기를 사용하는 모든 명령어가 이 모드이다. 또 무주소 명령어는 피연산자가 스택의 top이기에 이것도 Implied 모드 명령어이다.

<code>Immediate 모드</code><br/>
피연산자가 명령어 내에 존재하는 모드로 명령어에서 주소 필드 부분에 대신하여 피연산자 필드가 존재하게 된다.

<code>레지스터 모드</code><br/>
명령어의 주소 필드가 레지스터를 지정하는 경우 레지스터 모드라고 한다.

<code>레지스터 간접 모드</code><br/>
명령어가 피연산자의 주소를 가지고 있는 레지스터를 지정하는 모드이다. 즉 선택된 레지스터는 피연산자가 아니라 피연산자의 주소일 때를 뜻하며 이 모드의 장점으로 직접 메모리 주소를 지정하는 것보다 적은 비트가 들게 된다.

<code>자동증가(Auto Increment), 자동감소(Auto Decrement) 모드</code><br/>
레지스터 간접 모드와 유사하나 레지스터의 값이 메모리를 엑세스하고 난 후 자동적으로 증가하거나 감소하는 기능이 있다.

<code>직접 주소 모드</code><br/>
명령어의 주소 부분이 유효 명령어의 주소 필드에 의해 직접적으로 주어지는 모드로 분기(Branch) 형식의 명령어에서 실제 분기할 주소를 나타낸다.

<code>간접 주소 모드</code><br/>
명령어의 주소 필드에 유효 주소가 주어지는 방식으로 이 명령어를 수행하면 메모리로부터 명령어를 fetch하고 주소 부분으로 다시 유효 주소를 메모리로 가져와서 연산하는 구조로 수행된다.

<code>상대 주소 모드</code><br/>
프로그램 카운터(PC)가 명령어의 주소 부분과 더해져서 유효 주소가 결정되는 방식으로 명령어에서 분기해야 할 위치가 명령어 부근에 있을 때 자주 사용된다.<br/>
메모리 전체 주소를 지정하는 것보다 적은 비트가 들기에 더욱 짧은 주소 필드를 가질 수 있는 것이 장점이다.

<code>인덱스드 어드레싱 모드</code><br/>
인덱스 레지스터의 내용이 명령어의 주소 부분과 더해져서 유효주소를 얻어내는 방식이다.<br>
인덱스 레지스터는 인덱스 값을 가진 특별한 CPU 레지스터이다.

<code>베이스 레지스터 어드레싱 모드</code><br/>
베이스 레지스터의 내용이 명령어의 주소 부분과 더해져서 유효 주소를 얻어내는 방식이다.<br/>
인덱스드 어드레싱과 더해지는 레지스터의 종류만 달라진 방식이다.

두 방식의 차이점은 쓰임새에 있으며 인덱스 레지스터는 명령어 주소 부분에 대한 상대적인 위치를 가지고 있는데 반해, 베이스 레지스터는 베이스 주소를 가지고 있는 구조이기에 프로그램이나 데이터가 다른 세그먼트로 이동될 때 명령어의 displacement가 변경될 필요가 없다. 단 베이스 레지스터의 값이 다른 메모리 세그먼트의 시작 부분을 참고하여 변경하면 된다.

---

오늘 공부한 내용은 CPU에서 이론적인 명령어 구조에 대해서 특별히 더 집중해서 공부하였는데 CPU 연산 처리에 기본이 되는 내용이고 또 명령어를 통해서 실제 연산이 진행되기에 구조를 온전히 이해할 필요가 있었다.

이를 통해서 멀티 프로세싱에 대해 공부할 때 좀 더 이론적인 이해가 잘 되도록 도움을 받을 수 있을 것 같다.
