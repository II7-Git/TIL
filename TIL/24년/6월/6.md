# 24.06.06 TIL

## 알고리즘

### [백준-1419-등차수열의 합](https://www.acmicpc.net/problem/1419)

등차수열 문제에서 공차가 2~5 사이인 점을 보고 이 부분을 공략하여 경우의 수를 나누면 된다고 생각했다. 그래서 2~5 공차 각각의 규칙성을 파악해서 각 공차마다의 경우의 수를 구해서 문제를 해결했다.

오히려 단순하게 접근하려 해야 문제가 시간초과 없이 쉽게 풀려서 좀 더 쉽게 접근하는 법을 고민하게 해줬던 문제였다.

### [백준-2107-포함하는 구간](https://www.acmicpc.net/problem/2107)

결국 특정 구간 start, end 사이에 포함되는 구간이라면 start보다 이전에 시작하면 안되고 end 보다 뒤늦게 끝나면 안된다는 점이 중요했다.

그래서 위에 말한 경우를 총 N개의 구간에서 빼서 이 중 최대로 포함하는 구간의 개수를 구했다.

문제는 위 방식은 현재 구간을 포함하는 더 큰 구간이 있을 경우 중복해서 빠지는 오류가 있기에 더 이상 더 큰 구간이 없는 정답 구간에만 지장이 없을 뿐 그 이하 구간들에게는 문제가 있기에 정확한 수를 구하는 것은 아니기에 필요에 따라 변형해서 체크해야할 것 이다.

### [백준-16494-가장 큰 값](https://www.acmicpc.net/problem/16494)

전체 거리의 누적 거리들을 구해놓고 일정 구간 s->e까지 있다고 할 때 s와 e 사이에 누적 거리 중 가장 큰 거리를 s->e 사이에 거리로 기록해놓은 뒤 구간을 M개로 나누어서 브루트포스로 모든 구간 나눈 경우를 체크해서 가장 큰 값을 정답으로 하면 됐던 문제였다.

푸는 방식이 복잡해서 굉장히 어려웠던 문제였는데 다음에 유사한 문제가 나오면 이젠 접근 방법을 알 수 있어서 도움이 됐다.

### [백준-16469-소년 점프](https://www.acmicpc.net/problem/16469)

세 빌런들이 갈 수 있는 위치에 도달하는 최소 시간을 구해놓고 가장 늦게 해당 위치에 도달하는 빌런의 시간을 기준으로 세명이 모이는 시간을 체크했다.

단 아예 못모이는 경우도 있기에 이 경우들을 예외 처리 해주어야하고 체크했다면 그 결과에 따라 -1을 출력하거나 같은 시간에 모이는 위치들까지 구해서 정답을 출력하거나 하면 됐다.
