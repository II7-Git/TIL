# 스마트 포인터

## unique\_ptr

소유권 독점 자원의 관리에 유용하다.
즉, 기본적인 포인터와 같은 개념으로 봐도 무방하다

* 복사를 허용하지 않음
* unique\_ptr을 이동하면 원본 포인터는 null이 되고 대상 포인터로 소유권이 이전 됨
* 이동 전용 형식(move-only type)
* 소멸 시 자신이 가리키는 자원도 소멸자를 통해서 파괴시킴
* 커스텀 소멸자 지정도 가능하다
* unique\_ptr을 손쉽게 shared\_ptr로 변환 가능

## shared\_ptr

소유권 공유 자원 관리에 용이하다.

* 객체를 소유하는 것이 아니라 객체가 필요하지 않게 된 시점에 객체를 파괴시키는 것을 보장
* 마지막 shared\_ptr이 객체를 가리키지 않게되는 순간 파괴
* 객체의 수명을 신경 쓸 필요가 없다.
* 참조 횟수(reference count)를 통해서 관리
* 0이 될 시 파괴
* 생 포인터 크기에 두 배이다/
* 참조 횟수를 담을 메모리를 반드시 동적으로 할당해야 한다.
* 참조 횟수의 증가와 감소가 반드시 원자적 연산이어야 한다.
* 이동 생성 및 배정이 복사 생성 및 배정보다 빠르기에 꼭 필요한 경우가 아니면 이동을 사용한다.
* 하나의 생 포인터로 여러 개의 공유 포인터를 할당하는 짓은 하지 말아라

    > 각각의 제어블록이 생성될뿐더러 같은 객체가 여러번 파괴되는 문제도 발생한다
* 그렇기에 shared\_ptr에 생포인터를 넘기는 행동은 삼가는 것이 좋다
* 그냥 new를 통해 결과를 직접 전달하는 것이 바람직하다.
* 커스텀 소멸자도 지원한다. 또한 shared\_ptr 형식에 영향을 끼치지 않는다.

## weak\_ptr

shared\_ptr처럼 동작하되 대상을 잃을 수 있는 포인터가 필요할 때 용이하다.
즉, shared\_ptr과 동작은 비슷하나 참조 횟수에는 영향을 미치지 않는 포인터이다.

이때 생길 수 있는 문제는 자신이 가리키고 있는 대상이 파괴된 것을 포인터가 인지할 수 있냐의 여부인데 weak\_ptr은 이 문제를 해결해준다.

weak\_ptr은 독립적으로 쓰이는 스마트 포인터가 아니고 shared\_ptr를 보강해서 사용하는 포인터이다.

```C++
auto spw = std::make_shared<Widget>();

std::weak_ptr<Widget> wpw(spw);

spw = nullptr;

if(wpw.expried())
{
}
```

위와 같이 사용하게 되면 shared\_ptr의 참조 회수 1만 계속 유지되며 weak\_ptr은 참조 횟수에 영향을 미치지 않는다. 그리고 spw를 nullptr로 만들 때 참조 횟수가 0이 되며 객체가 소멸한다.
이때 weak\_ptr은 expired()를 통해서 자신이 가리키던 객체가 삭제됐는지를 쉽게 알아낼 수 있다.

weak\_ptr로부터 shared\_ptr을 새로 할당하는 방법도 있다

```C++
std::shared_ptr<Widget> spw1=wpw.lock();
// wpw가 만료이면 spw1은 nullptr이 된다.

auto spw2=wpw.lock();

std::shared_ptr<Widget> spw2(wpw);
```

* weak\_ptr의 사용 용도로는 캐싱, 옵저버 패턴에서의 관찰자 목록, shared\_ptr 순환 고리 방지 등이 있다.

## new를 직접 사용보단 std::make\_unique나 std::make\_shared를 사용하자

C++ 11에서는 make\_shared만 지원하고 C++ 14에서는 make\_unique도 지원한다.

* 자원 누수의 위험이 없다.
* 코드 중복을 피할 수 있다.
* 단, 언제나 사용 가능한 것은 아니다. 커스텀 소멸자 지정이 불가하고 중괄호를 사용한 초기화가 특정 상황에서는 어려울 수 있다.
* shared\_ptr의 경우 커스텀 메모리 관리 기능을 가진 클래스를 다루는 경우와 메모리가 넉넉하지 않은 시스템에서 큰 객체를 자주 다루어야 하고 weak\_ptr이 shared\_ptr보다 오래 살아남는 경우 오히려 make 함수가 부적합할 수 있다.

## Pimpl 관용구를 사용할 때 특수 멤버 함수들을 구현 파일에서 정의할 것

Pimpl 이란 캡슐화와 컴파일 시간 의존성 감소가 목적으로 클래스 세부 구현은 헤더에서 숨기고 포인터를 사용하여 실제 구현은 구현 파일에서 진행하는 방식을 뜻함

* Pimpl 관용구는 클래스 구현과 클래스 클라이언트 사이의 컴파일 의존성을 줄임으로서 빌드 시간이 감소
* unique\_ptr 형식의 pImpl 포인터를 사용할 때에는 특수 멤버 함수들을 클래스 헤더에 선언하고 구현 파일에서 구현 . 컴파일러가 기본으로 작성하는 함수 구현들이 사용하기에 적합한 경우에도 그렇게 해야 한다.
