# 현대적 C++ 적용하기

## 객체 생성 시 괄호'()' 와 중괄호 '{}'를 구분

* 균일 초기화가 가능한 중괄호 초기화 위주로 사용할 것!

    > 1. 기본적인 객체,비정적(non-static) 자료 멤버, 복사할 수 없는 객체(std::atomic 등등) 처럼 여러 객체 초기화 방법에서 동시에 다 사용가능한 균일 초기화 지원을 하는 것은 오직 중괄호'{}' 뿐이다.
    > 2. 중괄호 초기화는 암묵적 좁히기 변환(narrowing conversion)을 방지
    > * 암묵적 좁히기 변환 : double을 int로 변환하는 등의 암묵적 변환을 의미
    > 3. C++에서 가장 성가신 구문 해석(most vexing parse)에 자유로움
    > * most vexing parse : 생성자를 호출하려 했으나 함수가 호출되는 등의 문제
* 중괄호 초기화의 단점도 있다.
    * initializer\_list 의 중복적재 문제
    * vector v1(10,20) : 기대한 것은 값이 20인 벡터 요소 10개 생성
    * vector v2 {10,20} : 생성된 것은 값이 10,20인 2개의 요소
* 이런 식의 단점들도 존재할 수 있다.
* 따라서 상황에 맞게 괄호, 중괄호를 적절히 사용하여야 한다.

## 0과 NULL보다 nullptr 위주로 사용

* 0은 사실 int이지 Null이 아니다
* NULL도 포인터 형식이 아니다
* nullptr은 고유한 순환 정의가 돼있어 정수 형식과 포인터 형식에 대한 중복 적재가 될 일이 없다
* 이는 실제 null의 개념적 접근과 괴리가 있기에 nullptr 위주로 사용하는 것이 좋다.

## typedef보다는 별칭 선언을 선호하라

typedef 방식

```C++
typedef 기존형식 새로운이름;
```

using (별칭) 방식

```C++
using 새로운이름 = 기존형식;
```

사실상 같은 기능을 하는 역할

using의 장점

* typedef는 템플릿화 할 수 없지만 using은 가능하다.
* 이를 별칭 템플릿(alias template)이라 한다.

```C++
template<typename T>
using MyAllocList= std::list<T, MyAlloc<T>>;
```

쓰기도 편하고 이점도 많으니 using 위주로 사용할 것

## 범위 없는 enum보다 범위 있는 enum 선호

범위 없는 enum은 다른 곳에서 겹치는 이름을 사용할 수 없기에 범위를 지정하는
enum class로 범위를 지정해 사용하자

```C++
enum class Color {black,white, red};

auto white= false; // 범위 지정을 했기에 Color 안에 white랑 겹치지 않는다

Color c= Color::white; // 사용하려면 이렇게 사용
```

## 정의되지 않은 비공개 함수보다 삭제된 함수 선호

명시적으로 불가한 함수를 작성하고 싶을 때 private를 사용해 해당 함수가 동작 못하게 막는 것이 아니라 delete 키워드를 사용해 못하게 막는 것을 뜻한다.

```C++
private:
  void func();
```

위와 같은 방식으로 func()를 호출 못하게 하지 말고 아래와 같이 사용하라

```C++
public:
    void func() = delete;
```

이렇게 쓰는 이유는 명시적인 차단을 통해서 중복 적재 등의 이슈를 차단할 수 있기 때문이다.

## 재정의 함수는 override 선언

이것은 많이 사용하고 있으니 따로 정리는 하지 않겠지만 당연히 재정의 함수에는 호출해주자

## titerator보다 const\_iterator를 선호하라

* const\_iterator는 const를 가리키는 포인터의 STL 버전
* 수정되면 안될 값들을 가리킴
    사용 예

```C++
auto it= std::find(values.cbegin(),values.cend(),1983);
```

## 예외를 방출하지 않을 함수는 noexcept 선언

noexcept를 선언하면 최적화의 여지가 크기에 예외가 발생하지 않는다면 throw() 대신에 noexcept선언 해주자

* 최적화의 여지가 크다
* 이동 연산들과 swap, 메모리 해제 함수, 소멸자 등에서 특히 유용하다
* 대부분 함수는 noexcept가 아니라 예외에 중립적임

## 가능하다면 항상 constexpr을 사용할 것

constexpr : 컴파일 시간 상수를 나타내는 키워드로 해당 값을 컴파일 시간에 값을 계산할 수 있게하는 키워드

* const 와의 차이는 constexpr은 반드시 컴파일 시간에 값을 계산
* 함수,변수, 생성자 등에 사용 가능

## const 멤버 함수를 스레드에 안전하게 작성

* 동시적 문맥에서 쓰이지 않을 것이 확실한 경우가 아니면 const 멤버 함수는 스레드에 안전하게 작성할 것
* std::atomic 변수는 뮤텍스에 비해 성능상의 이점은 있지만 하나의 변수 또는 메모리 장소를 다룰 때에만 적합하다.

## 특수 멤버 함수들의 자동 작성 조건 숙지

특수 멤버 함수 : 컴파일러가 스스로 작성할 수 있는 멤버 함수들( ex : 기본 생성자와 소멸자, 복사 연산들, 이동 연산들)

* 이동 연산들은 이동 연산들이나 복사 연산들, 소멸자가 명시적으로 선언되어 있지 않은 클래스에서 자동 작성
* 복사 생성자는 복사 생성자가 명시되어있지 않는 클래스에서 자동 작성, 만약 이동 연산 하나라도 선언되어 있다면 삭제
* 멤버 함수 템플릿 때문에 특수 멤버 함수의 자동 작성이 금지되는 경우는 전혀 없다.
